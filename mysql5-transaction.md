[TOC]

![15352624354970.jpg](https://img.codesky.me/usr/uploads/2018/08/2262517482.jpg)

# 快速理解脏读、不可重复读、幻读？

 <https://blog.csdn.net/qq_33591903/article/details/81672260>

### 理解这三种由于并发访问导致的数据读取问题，再理解事务隔离级别就简单多了。

### 【1】脏读（读取未提交数据）

A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。就好像原本的数据比较干净、纯粹，此时由于B事务更改了它，这个数据变得不再纯粹。这个时候A事务立即读取了这个脏数据，但事务B良心发现，又用回滚把数据恢复成原来干净、纯粹的样子，而事务A却什么都不知道，最终结果就是事务A读取了此次的脏数据，称为脏读。

这种情况常发生于转账与取款操作中

| 时间顺序 | 转账事务                                          | 取款事务                                         |
| -------- | ------------------------------------------------- | ------------------------------------------------ |
| 1        |                                                   | 开始事务                                         |
| 2        | 开始事务                                          |                                                  |
| 3        |                                                   | 查询账户余额为2000元                             |
| 4        |                                                   | 取款1000元，余额被更改为1000元                   |
| 5        | 查询账户余额为1000元（产生脏读）                  |                                                  |
| 6        |                                                   | 取款操作发生未知错误，事务回滚，余额变更为2000元 |
| 7        | 转入2000元，余额被更改为3000元（脏读的1000+2000） |                                                  |
| 8        | 提交事务                                          |                                                  |
| 备注     | 按照正确逻辑，此时账户余额应该为4000元            |                                                  |

### 【2】不可重复读（前后多次读取，数据内容不一致）

事务A在执行读取操作，由整个事务A比较大，前后读取同一条数据需要经历很长的时间 。而在事务A第一次读取数据，比如此时读取了小明的年龄为20岁，事务B执行更改操作，将小明的年龄更改为30岁，此时事务A第二次读取到小明的年龄时，发现其年龄是30岁，和之前的数据不一样了，也就是数据不重复了，系统不可以读取到重复的数据，成为不可重复读。

| 时间顺序 | 事务A                                           | 事务B                |
| -------- | ----------------------------------------------- | -------------------- |
| 1        | 开始事务                                        |                      |
| 2        | 第一次查询，小明的年龄为20岁                    |                      |
| 3        |                                                 | 开始事务             |
| 4        | 其他操作                                        |                      |
| 5        |                                                 | 更改小明的年龄为30岁 |
| 6        |                                                 | 提交事务             |
| 7        | 第二次查询，小明的年龄为30岁                    |                      |
| 备注     | 按照正确逻辑，事务A前后两次读取到的数据应该一致 |                      |

### 【3】幻读（前后多次读取，数据总量不一致）

事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样，就像产生了幻觉一样，平白无故的多了几条数据，成为幻读。

| 时间顺序 | 事务A                                               | 事务B         |
| -------- | --------------------------------------------------- | ------------- |
| 1        | 开始事务                                            |               |
| 2        | 第一次查询，数据总量为100条                         |               |
| 3        |                                                     | 开始事务      |
| 4        | 其他操作                                            |               |
| 5        |                                                     | 新增100条数据 |
| 6        |                                                     | 提交事务      |
| 7        | 第二次查询，数据总量为200条                         |               |
| 备注     | 按照正确逻辑，事务A前后两次读取到的数据总量应该一致 |               |

------

趁热打铁，既然理解了脏读、不可重复读、幻读，那么接下来看看事务隔离级别是怎么个回事[【数据库】事务隔离级别](https://blog.csdn.net/qq_33591903/article/details/82079302?ops_request_misc=%7B%22request%5Fid%22%3A%22158632818519726869014448%22%2C%22scm%22%3A%2220140713.130056874..%22%7D&request_id=158632818519726869014448&biz_id=0&utm_source=distribute.pc_search_result.none-task-blog-blog_SOOPENSEARCH-1)

<https://blog.csdn.net/qq_33591903/article/details/82079302>


# 事务隔离级别

为了更好地说明事务隔离级别，请先移步快速理解脏读、不可重复读、幻读。

有四种隔离级别，分别是读未提交（Read uncommitted），读已提交（Read committed），可重复读（Repeatable read），可串行化（Serializable），用来解决数据库操作中产生的各种问题。

### 一、读未提交（Read uncommitted）

在这种隔离级别下，所有事务能够读取其他事务未提交的数据。读取其他事务未提交的数据，会造成脏读。因此在该种隔离级别下，不能解决脏读、不可重复读和幻读。

------

读未提交可能会产生脏读的现象，那么怎么解决脏读呢？那就是使用读已提交。

------

### 二、读已提交（Read committed）

在这种隔离级别下，所有事务只能读取其他事务已经提交的内容。能够彻底解决脏读的现象。但在这种隔离级别下，会出现一个事务的前后多次的查询中却返回了不同内容的数据的现象，也就是出现了不可重复读。

注意【1】这是大多数数据库系统默认的隔离级别，例如Oracle和SQL Server，但mysql不是。

------

已提交可能会产生不可重复读的现象，我们可以使用可重复读。

------

### 三、可重复读（Repeatable read）

在这种隔离级别下，所有事务前后多次的读取到的数据内容是不变的。也就是某个事务在执行的过程中，不允许其他事务进行update操作，但允许其他事务进行add操作，造成某个事务前后多次读取到的数据总量不一致的现象，从而产生幻读。

注意【1】这才是mysql的默认事务隔离级别

------

可重复读依然会产生幻读的现象，此时我们可以使用串行化来解决。

------

### 四、可串行化（Serializable）

在这种隔离级别下，所有的事务顺序执行，所以他们之间不存在冲突，从而能有效地解决脏读、不可重复读和幻读的现象。但是安全和效率不能兼得，这样事务隔离级别，会导致大量的操作超时和锁竞争，从而大大降低数据库的性能，一般不使用这样事务隔离级别。

------

### 下面用一张表格来表示他们能够解决的问题

| **隔离级别**                 | **脏读**  | **不可重复读** | **幻读** |
| ---------------------------- | --------- | -------------- | -------- |
| 读未提交（Read uncommitted） | ×(未解决) | ×              | ×        |
| 读已提交（Read committed）   | √(解决)   | ×              | ×        |
| 可重复读（Repeatable read）  | √         | √              | ×        |
| 可串行化（Serializable）     | √         | √              | √        |

当然，以上的内容是一种规范，不同的数据库厂商可以有不同的实现。例如在mysql的可重复读的级别上，使用间隙锁的方式就已经解决了幻读的问题。详细的加锁处理过程可以参考这篇文章[【数据库】MySQL 加锁处理分析](https://blog.csdn.net/qq_33591903/article/details/105365777)。
